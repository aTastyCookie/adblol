/* [Usage]
 > var logger = require('./common/logger.js');

 > var log = logger.create(); //means only output to stderr (usually means console)
 > var log = logger.create( 'someDir/myLog.txt' ); //same as following code but with backupDays:1
 > var log = logger.create({ filePath: 'someDir/myLog.txt', backupDays: 3 });

 >                                                                   log('msg'); or log('msg\n');
 23:59:59.999 msg\n
 >                                                                   log('msg1\nMsg2');
 23:59:59.999 msg1\n
 23:59:59.999 Msg2\n
 >                                                                   log('msg1\nMsg2', {head:'[myHead]'});
 23:59:59.999 [myHead]msg1\n
 23:59:59.999 [myHead]Msg2\n
 >                                                                   log('msg', {stderr:true});
 23:59:59.999 msg\n
 23:59:59.999 msg\n  (for stderr output, usually means console)
 >                                                                   log('processing...', {noNewLine:true});
 >                                                                   log('done.', {noNewLine:true});
 >                                                                   log('newLogMsg');
 23:59:59.998 processing...done.\n
 23:59:59.999 newLogMsg
 >                                                                   log.context.todayLogFilePath
 someDir/myLog_20131231.txt

 [Detail]
 Write log with head format '23:59:59.999 ' to each line head and new line appended.
 Fatal error will be output to stderr (usually means console). You can check logger.getLastError().

 When use file output, the file will be created when day changes.
 When first output or day changed, it will open/create log file name like myLog_20131231.txt with append mode,
 and delete any file <= myLog_20131224.txt.
 */
'use strict';
var fs = require('fs'), path = require('path');

var lastError = '', head = '', date = new Date(0), dd = -1, re_basenameSuffix = /^_\d{8}$/; //_YYYYMMDD

function makeSuffix(dt) { //_YYYYMMDD   //note: must match re_basenameSuffix
  return '_' + dt.getFullYear() + dpad2(dt.getMonth() + 1) + dpad2(dt.getDate());
}
function dpad2(d) {
  return (d < 10) ? '0' + d : d.toString();
}
function dpad3(d) {
  return (d < 10) ? '00' + d : (d < 100) ? '0' + d : d.toString();
}

/*
 * create new log file for today and delete too old backup files
 */
function createNewLogFileForToday(context) {
  //note: when enter here, date, dd means previous day, not today.
  var minDate = new Date(date);
  minDate.setDate(dd - 1 - context.backupDays);
  var minSuffix = makeSuffix(minDate);

  var dir = path.dirname(context.filePath);
  var ext = path.extname(context.filePath);
  var base = path.basename(context.filePath, ext);

  /*
   * delete old log files
   */
  try {
    fs.readdirSync(dir).forEach(function (name) {
      if (path.extname(name) === ext) {
        var _base = path.basename(name, ext);
        if (_base.slice(0, base.length) === base) {
          var _suffix = _base.slice(base.length);
          if (_suffix <= minSuffix && re_basenameSuffix.test(_suffix)) {
            try {
              fs.unlinkSync(dir + '/' + name);
            } catch (e) {
            }
          }
        }
      }
    });
  }
  catch (e) {
    if (e.code !== 'ENOENT') {
      lastError = 'Failed to search or delete old log files. ' + e;
      process.stderr.write(head + lastError + '\n');
    }
  }

  /*
   * create new log file for today
   */
  context.yesterdayLogFilePath = context.todayLogFilePath || (dir + '/' + base + makeSuffix(new Date(date.valueOf() - 86400000)) + ext);
  context.todayLogFilePath = dir + '/' + base + makeSuffix(date) + ext;
  try {
    context.fd = fs.openSync(context.todayLogFilePath, 'a'); //use append mode for multi-process
  }
  catch (e) {
    context.err_create = true;
    lastError = 'Failed to open/create file with append mode. ' + e;
    process.stderr.write(head + lastError + '\n');
  }
}//end of createNewLogFileForToday


/**
 * write msg to log file or stderr
 * @param context
 * @param msg (any type)
 * @param option
 *    (
 *      noNewLine: <Boolean> (default: false),
 *      head:      <String>  (default: ''),
 *      stderr:    <Boolean> (default: false)
 *    })
 */
function __log(context, msg, option) {
  var nowMs = Date.now();
  if (nowMs !== date.getTime()) {
    date.setTime(Date.now());

    //make head '23:59:59.999 '
    head = dpad2(date.getHours()) + ':' + dpad2(date.getMinutes()) + ':' + dpad2(date.getSeconds()) + '.' + dpad3(date.getMilliseconds()) + ' ';

    //close current and create new log file if date changed
    if (context.filePath && date.getDate() !== dd) {
      dd = date.getDate();
      __close(context);
      createNewLogFileForToday(context);
    }
  }

  msg = String(msg).replace('\0', '');
  var actualHead = (option && option.head) ? (head + option.head) : head;

  //remove last new line char
  var origMsgIsEndedWithNewLine = (msg.charCodeAt(msg.length - 1) === 0xa);
  if (origMsgIsEndedWithNewLine) {
    msg = msg.slice(0, -1);
  }

  //prepend head to each line. To disable this, just change to "var s = msg"
  var s = msg.replace(/\n/g, '\n' + actualHead);

  if (option && option.noNewLine === true) {
    if (context.previousLineHaveEnded) {
      s = actualHead + s;
    }
    if (origMsgIsEndedWithNewLine) {
      s += '\n';
    }
    context.isAutoAppendNewLineMode = false;
    context.previousLineHaveEnded = origMsgIsEndedWithNewLine;
  } else {
    if (context.previousLineHaveEnded) {
      s = actualHead + s + '\n';
    } else {
      s = '\n' + actualHead + s + '\n';
    }
    context.isAutoAppendNewLineMode = true;
    context.previousLineHaveEnded = true;
  }

  //write to file if filePath is specified
  var ok = false;
  if (context.fd !== -1) {
    try {
      ok = fs.writeSync(context.fd, s);
    } catch (e) {
      if (!context.err_write) {
        context.err_write = true;
        lastError = 'Failed to append log to file. ' + e;
        process.stderr.write(actualHead + lastError + '\n');
      }
    }
  }

  //write to stderr if failed or no filePath specified
  if (!ok || (option && option.stderr === true)) {
    try {
      process.stderr.write(s);
    } catch (e) {
      lastError = e.message;
    }
  }

  return nowMs;
}

/**
 * create a log context and return a log function which has been bound to the context so can be called directly.
 * @param option option or filePath
 * @returns function log(msg, option {noNewLine:<Boolean>, head:<String>, stderr:<Boolean>}). See __log
 */
function create(option/*optional*/) {
  //create logger context
  var context = {
    fd: -1, //file descriptor
    isAutoAppendNewLineMode: true,
    previousLineHaveEnded: true,
    filePath: null, //null or empty string means output to stderr
    backupDays: 7 //DO NOT set to 0, otherwise it will delete itself when day changed
  };

  if (option) {
    if (typeof(option) === 'object') {
      //copy some necessary config
      context.filePath = option.filePath;
      if (option.backupDays >= 1) {
        context.backupDays = option.backupDays;
      }
    }
    else if (typeof(option) === 'string') {
      context.filePath = option;
    }
  }

  //return a log function which has been bound to the context so can be called directly.
  var bound_func = function (msg, option) {
    __log(context, msg, option);
  };

  //save context just for later do release method
  bound_func.context = context;
  return bound_func;
}

function __close(context) {
  if (context.fd !== -1) {
    try {
      fs.closeSync(context.fd);
    } catch (e) {
    }
    context.fd = -1;
    context.err_write = false;
    context.err_create = false;
  }
}

/**
 * close log
 * @param log
 */
function close(log) {
  if (log && log.context) {
    __close(log.context);
    log.context.filePath = null;
  }
}

/**
 * get last error
 * @returns {string}
 */
function getLastError() {
  return lastError;
}

exports.create = create;
exports.close = close;
exports.getLastError = getLastError;